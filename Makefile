.PHONY: help build clean test fmt lint run install dev

# Binary output directory
BIN_DIR := .bin
BINARY := $(BIN_DIR)/goxcel

# Default target
help: ## Show this help message
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}'

build: ## Build the CLI binary
	@echo "Building goxcel..."
	@mkdir -p $(BIN_DIR)
	go build -o $(BINARY) ./cmd
	@echo "Build complete: $(BINARY)"

build-all: ## Build for all platforms
	@echo "Building for multiple platforms..."
	@mkdir -p $(BIN_DIR)
	GOOS=darwin GOARCH=amd64 go build -o $(BIN_DIR)/goxcel-darwin-amd64 ./cmd
	GOOS=darwin GOARCH=arm64 go build -o $(BIN_DIR)/goxcel-darwin-arm64 ./cmd
	GOOS=linux GOARCH=amd64 go build -o $(BIN_DIR)/goxcel-linux-amd64 ./cmd
	GOOS=windows GOARCH=amd64 go build -o $(BIN_DIR)/goxcel-windows-amd64.exe ./cmd
	@echo "Multi-platform build complete"

clean: ## Clean build artifacts
	@echo "Cleaning build artifacts..."
	rm -rf $(BIN_DIR)
	rm -f output.xlsx
	@echo "Clean complete"

test: ## Run tests
	@echo "Running tests..."
	go test ./... -v

test-coverage: ## Run tests with coverage and print report to stdout only
	@echo "Running tests with coverage..."
	@PKGS=$$(go list ./... | grep -v '/cmd$$'); \
	COVERPKG=$$(echo $$PKGS | tr ' ' ','); \
	PROFILE=$$(mktemp -t coverage.XXXXXX); \
	go test -covermode=atomic -coverpkg=$$COVERPKG $$PKGS -coverprofile=$$PROFILE >/dev/null; \
	echo "Coverage report (functions):"; \
	go tool cover -func=$$PROFILE; \
	rm -f $$PROFILE

coverage-ci: ## Print total coverage to stdout (for CI logs) and write profile
	@echo "Generating coverage (printing total and saving coverage.out)..."
	@PKGS=$$(go list ./... | grep -v '/cmd$$'); \
	COVERPKG=$$(echo $$PKGS | tr ' ' ','); \
	go test -covermode=atomic -coverpkg=$$COVERPKG $$PKGS -coverprofile=coverage.out >/dev/null; \
	go tool cover -func=coverage.out | tail -n1

coverage-open: ## (Deprecated) Open HTML coverage report if generated elsewhere
	@echo "No HTML coverage generated by default. Use 'go tool cover -html=coverage.out -o coverage.html' if needed."

fmt: ## Format code
	@echo "Formatting code..."
	go fmt ./...
	@echo "Format complete"

fmt-check: ## Check if code is formatted
	@echo "Checking code formatting..."
	@if [ -n "$$(gofmt -l .)" ]; then \
		echo "The following files need formatting:"; \
		gofmt -l .; \
		exit 1; \
	else \
		echo "All Go files are properly formatted!"; \
	fi

lint: ## Lint code
	@echo "Linting code..."
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run ./...; \
	else \
		echo "golangci-lint not found. Install with:"; \
		echo "  brew install golangci-lint"; \
		echo "  # or"; \
		echo "  go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest"; \
	fi

vet: ## Run go vet
	@echo "Running go vet..."
	go vet ./...

run: build ## Build and run with sample data (JSON)
	@echo "Running goxcel with sample JSON data..."
	$(BINARY) generate --template .etc/sample.gxl --data .etc/sample.json --output output.xlsx
	@echo "Generated: output.xlsx"

run-yaml: build ## Build and run with sample data (YAML)
	@echo "Running goxcel with sample YAML data..."
	$(BINARY) generate --template .etc/sample.gxl --data .etc/sample.yaml --output output.xlsx
	@echo "Generated: output.xlsx"

run-dry: build ## Build and run in dry-run mode
	@echo "Running goxcel in dry-run mode..."
	$(BINARY) generate --template .etc/sample.gxl --data .etc/sample.json --dry-run

install: ## Install the binary to $GOPATH/bin
	@echo "Installing goxcel..."
	go install ./cmd
	@echo "Installed to $$(go env GOPATH)/bin/goxcel"

dev: fmt vet test ## Run development checks (format, vet, test)
	@echo "Development checks complete"

check: fmt-check vet lint test ## Run all checks
	@echo "All checks passed!"

deps: ## Download dependencies
	@echo "Downloading dependencies..."
	go mod download
	go mod tidy
	@echo "Dependencies updated"

deps-update: ## Update dependencies
	@echo "Updating dependencies..."
	go get -u ./...
	go mod tidy
	@echo "Dependencies updated"

example: ## Run example generation
	@echo "Generating example Excel file..."
	@if [ ! -f $(BINARY) ]; then make build; fi
	$(BINARY) generate --template .etc/sample.gxl --data .etc/sample.json --output output.xlsx
	@echo "Example generated: output.xlsx"

debug: ## Build with debug flags and run
	@echo "Building with debug flags..."
	@mkdir -p $(BIN_DIR)
	go build -gcflags="all=-N -l" -o $(BIN_DIR)/goxcel-debug ./cmd
	@echo "Debug build complete: $(BIN_DIR)/goxcel-debug"

benchmark: ## Run benchmarks
	@echo "Running benchmarks..."
	go test -bench=. -benchmem ./...

profile: ## Run with CPU profiling
	@echo "Running with CPU profiling..."
	go test -cpuprofile=cpu.prof -bench=. ./...
	@echo "Profile saved to cpu.prof"
	@echo "View with: go tool pprof cpu.prof"

docker-build: ## Build Docker image
	@echo "Building Docker image..."
	docker build -t goxcel:latest .
	@echo "Docker image built: goxcel:latest"

docs-build: ## Build documentation with mdbook
	@echo "Building documentation..."
	@if ! command -v mdbook >/dev/null 2>&1; then \
		echo "Error: mdbook not found. Install with:"; \
		echo "  cargo install mdbook"; \
		echo "  # or"; \
		echo "  brew install mdbook"; \
		exit 1; \
	fi
	cd docs && mdbook build
	@echo "Documentation built: docs/dist/index.html"

docs-serve: ## Serve documentation with live reload
	@echo "Starting documentation server..."
	@if ! command -v mdbook >/dev/null 2>&1; then \
		echo "Error: mdbook not found. Install with:"; \
		echo "  cargo install mdbook"; \
		echo "  # or"; \
		echo "  brew install mdbook"; \
		exit 1; \
	fi
	cd docs && mdbook serve --open

docs-clean: ## Clean documentation build artifacts
	@echo "Cleaning documentation..."
	rm -rf docs/dist
	@echo "Documentation cleaned"

.DEFAULT_GOAL := help
